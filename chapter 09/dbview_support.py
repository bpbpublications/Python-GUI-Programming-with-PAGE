#! /usr/bin/env python3
#  -*- coding: utf-8 -*-
#
#! /usr/bin/env python
#  -*- coding: utf-8 -*-
# ======================================================
#     dbview_support.py
#  ------------------------------------------------------
# Created for Learning PAGE
# Written by G.D. Walters
# Copyright (c) 2023 by G.D. Walters
# This source code is released under the MIT License
# ======================================================
# Support module generated by PAGE version 7.6
#  in conjunction with Tcl version 8.6
#    Jan 07, 2023 09:22:54 AM CST  platform: Linux
#    Jan 08, 2023 07:55:03 AM CST  platform: Linux
#    Jan 10, 2023 06:11:18 AM CST  platform: Linux
#    Jan 10, 2023 06:03:55 PM CST  platform: Linux
#    Jan 12, 2023 08:54:04 AM CST  platform: Linux

import sys
import os
import platform
import pprint
import datetime
import sqlite3
import dbutils
from dbutils import quote
import tomli_w
import tomli
import shared

# -----------------------------------------------
import tkinter as tk
import tkinter.ttk as ttk
from tkinter.constants import *
from tkinter import messagebox
from tkinter import simpledialog

# -----------------------------------------------
import dbview

location = dbview._location

_debug = True  # False to eliminate debug printing from callback functions.


def main(*args):
    """Main entry point for the application."""
    global root
    root = tk.Tk()
    root.protocol("WM_DELETE_WINDOW", root.destroy)
    # Creates a toplevel widget.
    global _top1, _w1
    _top1 = root
    _w1 = dbview.Main(_top1)
    startup()
    root.mainloop()


def startup():
    """This function is called just before the form is shown to
    the user.  All setup and configuration processes are done
    here."""
    shared.showDeleted = False
    # Get startup information from the configuration file
    shared.config_data = get_configuration_information()
    showdeletedrecords = shared.config_data["Startup"]["showdeleted"]
    if showdeletedrecords == True:
        _w1.tch47.set(1)
        shared.showDeleted = True
    else:
        _w1.tch47.set(0)
        shared.showDeleted = False
    show_program_info()
    sty = ttk.Style()
    # Load the various theme .tcl files
    load_tcl_themes()
    # set the theme
    theme = shared.config_data["Theme"]["current"]
    sty.theme_use(theme)
    # TLabels don't properly respond to Themes.  Fix the Label backgrounds
    fix_labels()
    # ===================================================
    # Setup for the Database
    # ===================================================
    database_name = "Company.db"
    open_database(database_name)
    # Get the department information from the database
    depts = load_departments()
    # Load that information into the TCombobox
    _w1.TCombobox1["values"] = depts
    # Get the employee records from the database
    shared.actual_records = 0
    get_emps()
    global emprecs
    shared.num_records = len(emprecs)
    shared.currentrec = 1
    # Load the form with the first record
    load_form("id", shared.currentrec)
    # ===================================================
    # Set up for the Time of day display
    # ===================================================
    shared.timer_id = root.after(0, on_time_update)
    shared.edit_mode = ""
    _w1.btnRestore.configure(state=DISABLED)
    _w1.btnUnEdit.configure(state=DISABLED)
    _w1.TEntry1.configure(state=DISABLED)
    # Start in the display mode..."Lock" all the TEntry widgets
    setup_for_edit(True)
    # Set the icon for when the app is minimized
    set_icon()
    # Finally, center the form in the monitor screen
    centre_screen(998, 516)


def setup_for_edit(lock=True):
    """This function will "lock" the TEntry widgets if lock=True,
    so that no changes can be made by accident."""
    widgetlist = [
        _w1.TEntFName,
        _w1.TEntMName,
        _w1.TEntLName,
        _w1.TEntAddr1,
        _w1.TEntAddr2,
        _w1.TEntCity,
        _w1.TEntState,
        _w1.TEntPostal,
        _w1.TEntDOB,
        _w1.TEntPhone,
        _w1.TCombobox1,
    ]
    for widget in widgetlist:
        if lock:
            widget.configure(state=DISABLED)
        else:
            widget.configure(state=NORMAL)


def show_program_info():
    """This function simply prints some information to the terminal like
    the version of Python, the path to the program, the program version
    and so on."""
    global version
    pv = platform.python_version()
    print(f"Running under Python {pv}")
    # Set the path for the icon files
    print(f"Program running from {location}")
    version = "0.0.2"
    print(f"Version: {version}")
    print(f"Current Theme: {shared.config_data['Theme']['current']}")
    print(f"Available Themes: {shared.config_data['Theme']['available_themes']}")
    # print(f"Show Deleted Records: {shared.config_data['Startup']['showdeleted']}")


def get_configuration_information():
    """This function reads the TOML configuration file into a dictionary
    for use as needed."""

    with open("config.toml", "rb") as f:
        shared.config_data = tomli.load(f)
    return shared.config_data


def update_config_data():
    """This function writes the TOML configuration file, usually is called when
    a change has been made to the configuration dictionary"""
    with open("config.toml", "wb") as f:
        tomli_w.dump(shared.config_data, f)


def load_tcl_themes():
    # ===================================================
    # This will load the various tcl Themes.
    # ===================================================
    # Load my NotSoDark theme
    _top1.tk.call("source", os.path.join(location, "themes", "notsodark_0.1.05.1.tcl"))
    _top1.tk.call("source", os.path.join(location, "themes", "waldorf.tcl"))


def load_form(how, which):
    """This fucntion reads one database record and fills in
    the proper TEntry fields."""
    global emprecs, temprec
    if _debug:
        print(f"How: {how}")
        print(f"{which=}")
        print(f"Record Requested: {which}")
        print(f"Number of records: {shared.num_records}")

    clear_form()
    # shared.dirty = False
    shared.num_records = len(emprecs)
    if how == "id":
        if which > shared.num_records:
            which = shared.num_records
        recnum = which
        disp = f"Record {recnum} of {shared.num_records}"
        _w1.EntryRecordInfo.set(disp)
        if how == "actual":
            pass
        rec = emprecs[which - 1]
    elif how == "actual":
        for r in emprecs:
            # print(r[0])
            if r[0] == which:
                rec = r
        # rec = emprecs[which]
    shared.current_record_data = rec
    _w1.EntryFirstName.set(rec[1])
    _w1.EntryMiddleName.set(rec[2])
    _w1.EntryLastName.set(rec[3])
    _w1.EntryAddr1.set(rec[4])
    _w1.EntryAddr2.set(rec[5])
    _w1.EntryCity.set(rec[6])
    _w1.EntryState.set(rec[7])
    _w1.EntryPostal.set(rec[8])
    _w1.EntryDOB.set(rec[9])
    _w1.EntryPhone.set(rec[10])
    _w1.TCombobox1.current(rec[11] - 1)
    if rec[12] == 0:
        dele = " deleted"
        _w1.btnRestore.configure(state=NORMAL)
        _w1.TButton9.configure(state=DISABLED)
    else:
        dele = " "
        _w1.btnRestore.configure(state=DISABLED)
        _w1.TButton9.configure(state=NORMAL)
    _w1.RecordNumber.set(f"  Actual Record Number: {rec[0]} {dele}")


def get_emps():
    """This function gets the employee records from the database.  If the
    showDeleted parameter is true, all records will be retrieved regardless
    of the value in the Active database field.  Otherwise, only the records
    with a "1" in the Active field will be retrieved."""

    global emprecs
    if shared.showDeleted:
        sql = """SELECT *, COUNT(*) OVER(ORDER BY EmpID) as RecNumber
  FROM Employees"""
    else:
        sql = """SELECT *, COUNT(*) OVER(ORDER BY EmpID) as RecNumber
  FROM Employees where Active = 1"""
    emprecs = list(cursor.execute(sql))
    if emprecs:
        size = len(emprecs)
        actual_records = emprecs[size - 1][13]
        shared.actual_records = actual_records
    else:
        titl = "Database Viewer"
        msg = "Can't get Employee Records from Database.  Program will exit!"
        messagebox(titl, msg, parent=_top1, icon=messagebox.error)
        sys.exit()


def open_database(database_name):
    """This function will open the database. NOTE: IF THE DATABASE DOES
    NOT EXIST, A BLANK ONE WILL BE CREATED!"""
    global connection, cursor
    dbpath = os.path.join(location, database_name)
    connection = sqlite3.Connection(dbpath)
    cursor = connection.cursor()


def load_departments():
    """This function will pull all records from the Department table.  Each record
    comes back as a tuple, so in order to get just the department name, we
    step through the returned record, appending the department name to a separate
    list so we can use this information to fill the TCombobox."""
    sql = "SELECT DeptName FROM Department;"
    recs = list(cursor.execute(sql))
    lst = []
    for r in recs:
        lst.append(r[0])
    if len(recs) < 1:
        titl = "Database Viewer"
        msg = (
            "No records were returned for the Department table.  Program will now exit."
        )
        messagebox.showerror(titl, msg, parent=_top1, icon=messagebox.ERROR)
        sys.exit()
    return lst


def on_tbtnExit(*args):
    """Callback for the exit button"""
    if _debug:
        print("dbview_support.on_tbtnExit")
        for arg in args:
            print("    another arg:", arg)
        sys.stdout.flush()
    sys.exit()


def on_btnGoFirst(*args):
    """Callback for the goFirst button"""
    if _debug:
        print("dbview_support.on_btnGoFirst")
        for arg in args:
            print("    another arg:", arg)
        sys.stdout.flush()
    shared.currentrec = 1
    load_form("id", shared.currentrec)


def on_btnGoLast(*args):
    """Callback for the goLast button"""
    if _debug:
        print("dbview_support.on_btnGoLast")
        for arg in args:
            print("    another arg:", arg)
        sys.stdout.flush()
    shared.currentrec = shared.num_records
    load_form("id", shared.currentrec)


def on_btnGoNext(*args):
    """Callback for the goNext button"""
    if _debug:
        print("dbview_support.on_btnGoNext")
        for arg in args:
            print("    another arg:", arg)
        sys.stdout.flush()
    if shared.currentrec < shared.num_records:
        shared.currentrec += 1
        load_form("id", shared.currentrec)
    else:
        pass


def on_btnGoPrevious(*args):
    """Callback for the goPrevious button"""
    if _debug:
        print("dbview_support.on_btnGoPrevious")
        for arg in args:
            print("    another arg:", arg)
        sys.stdout.flush()
    if shared.currentrec > 1:
        shared.currentrec -= 1
        load_form("id", shared.currentrec)


def on_btnChangeTheme(*args):
    """Callback for the Change Theme button.
    This also calls the fix_labels function"""
    if _debug:
        print("dbview_support.on_btnChangeTheme")
        for arg in args:
            print("    another arg:", arg)
        sys.stdout.flush()

    current = shared.config_data["Theme"]["current"]
    if current == "notsodark":
        current = "waldorf"
    else:
        current = "notsodark"
    shared.config_data["Theme"]["current"] = current
    sty = ttk.Style()
    sty.theme_use(current)
    sty.the
    fix_labels()


def fix_labels():
    """This function will get the background color of the TFrame
    that is used to hold all the other widgets which is then
    used to set the background color of all the TLabel widgets."""
    sty = ttk.Style()
    _bg = sty.lookup("TFrame", "background")
    update_config_data()
    labels = [
        _w1.TLabel1,
        _w1.TLabel2,
        _w1.TLabel3,
        _w1.TLabel4,
        _w1.TLabel5,
        _w1.TLabel6,
        _w1.TLabel7,
        _w1.TLabel8,
        _w1.TLabel9,
        _w1.TLabel10,
        _w1.TLabel11,
        _w1.TLabel12,
        _w1.TLabel13,
    ]
    for lab in labels:
        lab.configure(background=_bg)


def find_by_name():
    """This function simply calls the askstring method of the simpledialog
    and returns what the user responded with."""
    resp = simpledialog.askstring(
        "Search for Last Name", "Enter Last Name to search for:"
    )
    return resp


def on_btnSearch(*args):
    """This is the callback for the btnSearch.
    This calls the simpledialog to get the name to search for,
    then uses a SQL statement to check last name is like the
    search term.  If found, the form is cleared and loaded with the
    proper record information.  Otherwise, a message box is shown
    stating that nothing was found."""
    if _debug:
        print("dbview_support.on_btnSearch")
        for arg in args:
            print("    another arg:", arg)
        sys.stdout.flush()
    resp = find_by_name()
    if resp != None:
        sql = f"""SELECT * FROM Employees WHERE LastName like '%{resp}%'"""
        found = list(cursor.execute(sql))
        if found:
            # print(found)
            rec = int(found[0][0])
            # print(f"{rec=}")
            clear_form()
            if shared.showDeleted:
                load_form("id", rec)  # Records are a list which is 0 based
            else:
                load_form("actual", rec)
            titl = "Database Viewer"
            msg = f"Search Success! Found {resp}"
            messagebox.showinfo(titl, msg, parent=_top1, icon=messagebox.INFO)
        else:
            titl = "Database Viewer"
            msg = f"'{resp}' not found in database!"
            messagebox.showerror(titl, msg, parent=_top1, icon=messagebox.ERROR)


def clear_form():
    """This function clears all the TEntry widgets."""
    widgetlist = [
        _w1.EntryFirstName,
        _w1.EntryMiddleName,
        _w1.EntryLastName,
        _w1.EntryAddr1,
        _w1.EntryAddr2,
        _w1.EntryCity,
        _w1.EntryState,
        _w1.EntryPostal,
        _w1.EntryDOB,
        _w1.EntryPhone,
    ]
    for widget in widgetlist:
        widget.set("")
    _w1.TCombobox1.set("")


def on_btnAbout(*args):
    """This is the callback function for btnAbout"""
    if _debug:
        print("dbview_support.on_btnAbout")
        for arg in args:
            print("    another arg:", arg)
        sys.stdout.flush()
    titl = "Database Viewer"
    msg = "Sorry, but This function is not yet finished."
    messagebox.showinfo(titl, msg, parent=_top1, icon=messagebox.INFO)


def on_btnAdd(*args):
    if _debug:
        print("dbview_support.on_btnAdd")
        for arg in args:
            print("    another arg:", arg)
        sys.stdout.flush()
    shared.edit_mode = "new"
    clear_form()
    _w1.TEntFName.focus_set()
    _w1.btnSave.configure(state=NORMAL)
    setup_for_edit(False)


def disable_record_move():
    """This function disables the record movement buttons"""
    _w1.TButton1.configure(state=DISABLED)
    _w1.TButton2.configure(state=DISABLED)
    _w1.TButton3.configure(state=DISABLED)
    _w1.TButton4.configure(state=DISABLED)


def enable_record_move():
    """This function enables the record movement buttons"""
    _w1.TButton1.configure(state=NORMAL)
    _w1.TButton2.configure(state=NORMAL)
    _w1.TButton3.configure(state=NORMAL)
    _w1.TButton4.configure(state=NORMAL)


def on_btnDelete(*args):
    if _debug:
        print("dbview_support.on_btnDelete")
        for arg in args:
            print("    another arg:", arg)
        sys.stdout.flush()
    titl = "Database Viewer"
    msg = "This will remove the current record from the Database.  Proceed?"
    resp = messagebox.askyesno(titl, msg, parent=_top1, icon=messagebox.QUESTION)
    if resp == True:
        sql = f"""UPDATE Employees SET Active=0 WHERE EmpID={shared.currentrec}"""
        cursor.execute(sql)
        connection.commit()
        get_emps()
        load_form("id", shared.currentrec)


def on_btnEdit(*args):
    if _debug:
        print("dbview_support.on_btnEdit")
        for arg in args:
            print("    another arg:", arg)
        sys.stdout.flush()
    temp_data = shared.current_record_data
    shared.edit_mode = "edit"
    _w1.btnUnEdit.config(state=NORMAL)
    _w1.btnEdit.config(state=DISABLED)
    disable_record_move()
    if temp_data[12] == 0:
        # record is deleted.  Complain!
        titl = "Database Viewer"
        msg = "The current record is marked as Deleted.  Restore the record First!"
        messagebox.showerror(titl, msg, parent=_top1, icon=messagebox.ERROR)
    else:
        _w1.btnSave.configure(state=NORMAL)
        # May not be needed
        current_record = shared.currentrec

        _w1.btnSave.configure(state=NORMAL)
        setup_for_edit(False)


def on_btnHelp(*args):
    if _debug:
        print("dbview_support.on_btnHelp")
        for arg in args:
            print("    another arg:", arg)
        sys.stdout.flush()
    titl = "Database Viewer"
    msg = "Sorry, but This function is not yet finished."
    messagebox.showinfo(titl, msg, parent=_top1, icon=messagebox.INFO)


def on_time_update():
    # ======================================================
    # Callback function for the Time display
    # ======================================================
    nowstring = f"{datetime.datetime.now():%X}"
    _w1.StatusTime.set(nowstring)
    shared.timer_id = root.after(500, on_time_update)


def on_btnSave(*args):
    """This is the save callback to write the data to the database.
    The actual write function is called from here, then it calls
    the setup for edit function and then reenables the record
    movement buttons"""
    if _debug:
        print("dbview_support.on_btnSave")
        for arg in args:
            print("    another arg:", arg)
        sys.stdout.flush()
    shared.fields = []
    if shared.edit_mode == "edit":
        shared.fields = [
            "FirstName",
            "MiddleName",
            "LastName",
            "Address1",
            "Address2",
            "City",
            "State",
            "PostalCode",
            "DateOfBirth",
            "PhoneNumber",
            "DepartmentID",
            "Active",
        ]
        check_for_changes(shared.currentrec)
    elif shared.edit_mode == "new":
        write_full_record()
        setup_for_edit(True)
        enable_record_move()
    else:
        pass


def check_for_changes(recnum):
    if _debug:
        print(f"Into check_for_changes - record: {recnum}")
    original_data = list(shared.current_record_data)
    changedfields = []
    newdata = []
    if _w1.EntryFirstName.get() != original_data[1]:
        changedfields.append(0)
        newdata.append(_w1.EntryFirstName.get())
    if _w1.EntryMiddleName.get() != original_data[2]:
        changedfields.append(1)
        newdata.append(_w1.EntryMiddleName.get())
    if _w1.EntryLastName.get() != original_data[3]:
        changedfields.append(2)
        newdata.append(_w1.EntryLastName.get())
    if _w1.EntryAddr1.get() != original_data[4]:
        changedfields.append(3)
        newdata.append(_w1.EntryAddr1.get())
    if _w1.EntryAddr2.get() != original_data[5]:
        changedfields.append(4)
        newdata.append(_w1.EntryAddr2.get())
    if _w1.EntryCity.get() != original_data[6]:
        changedfields.append(5)
        newdata.append(_w1.EntryCity.get())
    if _w1.EntryState.get() != original_data[7]:
        changedfields.append(6)
        newdata.append(_w1.EntryState.get())
    if _w1.EntryPostal.get() != original_data[8]:
        changedfields.append(7)
        newdata.append(_w1.EntryPostal.get())
    if _w1.EntryDOB.get() != original_data[9]:
        changedfields.append(8)
        newdata.append(_w1.EntryDOB.get())
    if _w1.EntryPhone.get() != original_data[10]:
        changedfields.append(9)
        newdata.append(_w1.EntryPhone.get())
    # Department needs to come from the Combobox
    dept = quote(_w1.combobox.get())
    dat = get_department_id(dept)
    if dat != original_data[11]:
        changedfields.append(10)
        newdata.append(dat)
    if _debug:
        print(f"Changed fields: {changedfields}")
        print(f"New Data: {newdata}")
    update_record(recnum, changedfields, newdata)


def update_record(which, changedfields, newdata):
    print("into update_record")
    sql1 = f"UPDATE Employees SET"
    endsql = f" WHERE EmpID = {which}"
    cntr = 0
    numtodo = len(changedfields)
    parts = []
    for field in changedfields:
        print(f"{field=} - {shared.fields[field]=} - {newdata[cntr]=}")
        if field == 10:
            sqltmp = " " + shared.fields[field] + f" = {newdata[cntr]}"
        else:
            sqltmp = " " + shared.fields[field] + " = " + quote(newdata[cntr])
        parts.append(sqltmp)
        cntr += 1
    sql = ",".join(parts)
    sql = sql1 + sql + endsql
    print(sql)
    cursor.execute(sql)
    print(f"Cursor.rowcount: {cursor.rowcount}")
    connection.commit()
    print(f"Cursor.rowcount: {cursor.rowcount}")
    lastrow = cursor.lastrowid
    print(f"{lastrow=}")
    get_emps()
    load_form("id", which)
    setup_for_edit(True)
    _w1.btnSave.configure(state=DISABLED)
    enable_record_move()


def write_full_record():
    # Get the data from each field:
    fn = _w1.EntryFirstName.get()
    mn = _w1.EntryMiddleName.get()
    ln = _w1.EntryLastName.get()
    add1 = _w1.EntryAddr1.get()
    add2 = _w1.EntryAddr2.get()
    if add2 == "":
        add2 = " "
    city = _w1.EntryCity.get()
    state = _w1.EntryState.get()
    postal = _w1.EntryPostal.get()
    dob = _w1.EntryDOB.get()
    phone = _w1.EntryPhone.get()
    dept = quote(_w1.combobox.get())
    print(fn, mn, ln, add1, add2, city, state, postal, dob, phone, dept)
    # Get department Primary key
    deptID = get_department_id(dept)

    sql2 = """INSERT INTO "Employees" (FirstName,MiddleName,LastName,Address1,Address2,City,State,PostalCode,DateOfBirth,PhoneNumber,DepartmentID,active) VALUES (?,?,?,?,?,?,?,?,?,?,?,?);"""
    info = (fn, mn, ln, add1, add2, city, state, postal, dob, phone, deptID, 1)
    try:
        cursor.execute(sql2, info)
        connection.commit()
        success = cursor.rowcount()
        lastrow = cursor.lastrowid
        print(f"{lastrow=}")
        get_emps()
        load_form("actual", shared.actual_records)
        if lastrow == 1:
            titl = "Database Viewer"
            msg = "Write to database successful"
            messagebox.showinfo(titl, msg, parent=_top1, icon=messagebox.INFO)
    except:
        titl = "Database Viewer"
        msg = "Failed to write to database"
        messagebox.showerror(titl, msg, parent=_top1, icon=messagebox.ERROR)


def on_TCheck(*args):
    """This function controls the show only active records
    or show all records"""
    if _debug:
        print("dbview_support.on_TCheck")
        for arg in args:
            print("    another arg:", arg)
        sys.stdout.flush()
    tf = _w1.tch47.get()
    if tf:
        shared.showDeleted = True
    else:
        shared.showDeleted = False
    clear_form()
    get_emps()
    load_form("id", 1)
    shared.config_data["Startup"]["showdeleted"] = shared.showDeleted
    update_config_data()


def on_btnUndoDelete(*args):
    """This function will change the active field from 0 (deleted) to 1"""
    if _debug:
        print("dbview_support.on_btnUndoDelete")
        for arg in args:
            print("    another arg:", arg)
        sys.stdout.flush()
    global emprecs  # currentrec
    trec = list(
        cursor.execute(f"SELECT * FROM Employees WHERE EmpID={shared.currentrec}")
    )
    if trec[0][12] == 0:
        titl = "Database Viewer"
        msg = "This will restore this record to Active Status.  Proceed?"
        resp = messagebox.askyesno(titl, msg, parent=_top1, icon=messagebox.QUESTION)
        if resp:
            sql = f"UPDATE Employees SET Active=1 WHERE EmpID={shared.currentrec}"
            cursor.execute(sql)
            print(f"{cursor.rowcount=}")
            connection.commit()
            print(f"{cursor.rowcount=}")
            if shared.showDeleted:
                sql = """SELECT *, COUNT(*) OVER(ORDER BY EmpID) as RecNumber
        FROM Employees"""
            else:
                sql = """SELECT *, COUNT(*) OVER(ORDER BY EmpID) as RecNumber
        FROM Employees where Active = 1"""
            emprecs = list(cursor.execute(sql))
            load_form("id", shared.currentrec)
    else:
        titl = "Database Viewer"
        msg = "Delete operation CANCELED!"
        resp = messagebox.showinfo(titl, msg, parent=_top1, icon=messagebox.INFO)


def get_department_id(deptname):
    sql1 = f"""SELECT DepartmentID FROM Department WHERE DeptName = {deptname}"""
    print(sql1)
    result = list(cursor.execute(sql1))
    print(result[0][0])
    return result[0][0]


def centre_screen(wid, hei):
    """This functin centres the form within the primary screen"""
    ws = root.winfo_screenwidth()
    hs = root.winfo_screenheight()
    x = (ws / 2) - (wid / 2)
    y = (hs / 2) - (hei / 2)
    root.geometry("%dx%d+%d+%d" % (wid, hei, x, y))


def on_btnCancelEdit(*args):
    if _debug:
        print("dbview_support.on_btnCancelEdit")
        for arg in args:
            print("    another arg:", arg)
        sys.stdout.flush()
    _w1.btnUnEdit.config(state=DISABLED)
    _w1.btnEdit.config(state=NORMAL)
    enable_record_move()
    shared.edit_mode = ""
    setup_for_edit(True)


def set_icon():
    # ======================================================
    # Sets the application icon...
    # ======================================================
    global progImagesPath
    img = os.path.join(location, "graphics", "database.png")
    shared.p1 = tk.PhotoImage(file=img)
    root.tk.call("wm", "iconphoto", root._w, shared.p1)


if __name__ == "__main__":
    dbview.start_up()
