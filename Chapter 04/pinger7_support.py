#! /usr/bin/env python
#  -*- coding: utf-8 -*-
#
# Support module generated by PAGE version 7.5rc
#  in conjunction with Tcl version 8.6
#    Jul 19, 2022 10:39:30 PM CDT  platform: Linux
#    Jul 19, 2022 11:07:56 PM CDT  platform: Linux
#    Jul 20, 2022 12:34:26 AM CDT  platform: Linux
#    Jul 20, 2022 02:40:11 AM CDT  platform: Linux
#    Jul 20, 2022 02:49:45 AM CDT  platform: Linux
#    Jul 20, 2022 02:57:12 AM CDT  platform: Linux
#    Jul 27, 2022 05:29:14 AM CDT  platform: Linux

import sys

import datetime
import logging
import subprocess
import platform
import os
import requests
import socket
from string import Template
import locale

import tkinter as tk
import tkinter.ttk as ttk
from tkinter.constants import *
from tkinter import messagebox

import pinger7

# ===================================================
# We will declare the debug flag here which makes it
# automatically a global.  Basically, I've wrapped most
# print statements with an 'if debug:' so things don't
# always print to the terminal.  There are a few exceptions
# to this, especially in the start_up function.
# ===================================================
debug = True
# debug = False

# ===================================================
# I've pulled the TkVars from the GUI.py module for both
# the main Toplevel form and the About Toplevel form and
# placed them here for easy reference.
# ===================================================
# TkVars form Main Form
# ===================================================
# rb1display = tk.StringVar()
# rb2disp = tk.StringVar()
# rb3disp = tk.StringVar()
# rb4display = tk.StringVar()
# ExternalIP = tk.StringVar()
# LastPingTime = tk.StringVar()
# PingsDone = tk.StringVar()
# SlowPings = tk.StringVar()
# FailedPings = tk.StringVar()
# PingDelay = tk.StringVar()
# PingDelay.set('1.0')
# TimesToPing = tk.StringVar()
# TimesToPing.set('0.0')
# selectbutton = tk.IntVar()
# selectedButton = tk.IntVar()
# ===================================================
# TkVars for About Box
# ===================================================
# ProgNameDisplay = tk.StringVar()
# VersionDisplay = tk.StringVar()
# AuthorDisplay = tk.StringVar()
# CopyrightDisplay = tk.StringVar()


def main(*args):
    """Main entry point for the application."""
    global root
    root = tk.Tk()
    root.protocol("WM_DELETE_WINDOW", root.destroy)
    # Creates a toplevel widget.
    global _top1, _w1
    _top1 = root
    _w1 = pinger7.pinger(_top1)
    # Creates the About form.
    global _top2, _w2
    _top2 = tk.Toplevel(root)
    _w2 = pinger7.About(_top2)
    start_up()
    # # Creates a toplevel widget.
    # global _top76, _w76
    # _top76 = tk.Toplevel(root)
    # _w76 = pinger7.pinger(_top76)
    # # Creates a toplevel widget.
    # global _top77, _w77
    # _top77 = tk.Toplevel(root)
    # _w77 = pinger7.About(_top77)
    root.mainloop()


def start_up():
    # ======================================================
    # function start_up()
    # ======================================================
    # sets important local variables and UI defaults
    # ======================================================
    global Running, NumberOfPings, slow, failed
    global ProgName, Author, Version, TargetIP
    global osplatform, location, temp
    global NumberOfPings, Timer_id, debug, Version
    global copyright_symbol, Language, addresses
    copyright_symbol = "\u00A9"
    Version = "0.10.1b"
    location = pinger7._location
    osplatform = sys.platform
    # ======================================================
    # Setup for multi-language support...
    # ======================================================
    # Language = 'Norwegian'
    lang = locale.setlocale(locale.LC_ALL, "")
    # print lang[:2]
    if lang[:2] == "en":
        Language = "English"
        print("Using English")
    elif lang[:2] == "nn":
        Language = "Norwegian"
        print("Bruke norsk")
    # Language = 'English'
    do_languages(Language)

    # Get the public ip and set the label
    _w1.ExternalIP.set(getPublicIp())
    # Clear the empty labels
    _w1.LastPingTime.set("")
    _w1.PingsDone.set("")
    _w1.SlowPings.set("")
    _w1.FailedPings.set("")
    # set defaults

    global siteIpList, rblist
    siteIpList = ["8.8.8.8", "8.8.4.4", "192.168.1.12", "192.168.1.236", "192.168.1.67"]
    rblist = [
        _w1.rbsite1,
        _w1.rbsite2,
        _w1.rbsite3,
        _w1.rbsite4,
        _w1.rbsite5,
    ]
    _w1.rbsite1.invoke()
    # global PingTo
    TargetIP = siteIpList[0]
    cntr = 0
    for rb in rblist:
        rb.configure(text=siteIpList[cntr])
        cntr += 1
    _w1.PingDelay.set(5)
    _w1.TimesToPing.set(5)
    NumberOfPings = 0
    slow = 0
    failed = 0
    Running = "0"
    global Copyright
    Copyright = "Copyright " + copyright_symbol + " 2018,2022 by G.D. Walters"
    temp = []

    print(f"Program Version: {Version}")
    pv = platform.python_version()
    print(f"Running under Python {pv}")
    # Set the path for the language files
    print(f"Working Directory: {location}")

    # Hide the about box for now
    hide_about()
    # centre_screen(652, 605)


def read_file(filename):
    # ======================================================
    # function read_file()
    # ======================================================
    # Read file, strip \n and put lines into a list
    # ======================================================
    with open(filename) as f:
        lines = f.read().splitlines()
    return lines


def getPublicIp():
    # ======================================================
    # function getPublicIp()
    # ======================================================
    # requests public ip address from https://api.ipify.org
    # ======================================================
    try:
        return requests.get("https://api.ipify.org").text
    except:
        return 0


def getLocalInfo():
    # ======================================================
    # function getLocalInfo()
    # ======================================================
    # gets and sets machine name, local ip address and gateway
    host = socket.gethostname()
    if platform.system() == "Windows":
        # Under windows use 'route print -4', assign to a string.
        # Use .find('Gateway') use that as starting position into string
        # and slice 100 characters. split that. Gateway should be #5
        # ip should be #6
        # -----------------------------------------
        data = os.popen("route print -4").read()
        p = data.find("Gateway")
        s = data[p : p + 100].split()
        # This, however looks WAY cooler
        # s = data[data.find('Gateway'):data.find('Gateway')+100].split()
        gateway = s[5]
        ipaddr = s[6]
    else:
        gw = os.popen("ip -4 route show").read()
        # slice at 'default via '+12 to ' dev ' = gateway
        # slice at 'src '+4 to 'metric'
        part1 = gw[gw.find("default via ") + 12 : gw.find(" dev ")]
        part2 = gw[gw.find("src ") + 4 :].split()
        gateway = part1
        ipaddr = part2[0]
    return ipaddr, gateway, host


def on_tick():
    # ======================================================
    # function on_tick()
    # ======================================================
    # emulates a timer to do things on a recurring basis
    # based on root.after routine
    # ======================================================
    global NumberOfPings, Timer_id, Running, failed, slow, TargetIP
    now = datetime.datetime.now().time()
    tim = datetime.datetime.now().strftime("%x %X")
    _w1.LastPingTime.set(tim)
    NumberOfPings += 1
    PingsTotal = int(_w1.TimesToPing.get())
    try:
        # resp, values = do_ping(PingToAddress, "3", "2")
        resp, values = do_ping(TargetIP, "3", "2")
        if resp != 0:
            failed += 1
            _w1.FailedPings.set(failed)
            logging.warning(LogPingFail.substitute(num=NumberOfPings, tim=tim))
            _w1.txtErrors.insert(
                END, LogPingFail.substitute(num=NumberOfPings, tim=tim) + "\n"
            )
            print(LogPingFail.substitute(num=NumberOfPings, tim=tim))
            _w1.lblExternalIP.configure(background="red2")
        else:
            _w1.lblExternalIP.configure(background="green2")
            if float(values[1]) > 50.0:
                slow += 1
                _w1.SlowPings.set(slow)
                _w1.lblExternalIP.configure(background="yellow")
                logging.warning(
                    SlowPingDisplay.substitute(
                        num=NumberOfPings,
                        tim=tim,
                        max=values[2],
                        avg=values[1],
                        min=values[0],
                    )
                )
                _w1.txtErrors.insert(
                    END,
                    SlowPingDisplay.substitute(
                        num=NumberOfPings,
                        tim=tim,
                        max=values[2],
                        avg=values[1],
                        min=values[0],
                    )
                    + "\n",
                )
                print(
                    SlowPingDisplay.substitute(
                        num=NumberOfPings,
                        tim=tim,
                        max=values[2],
                        avg=values[1],
                        min=values[0],
                    )
                )
            else:
                logging.info(
                    LogPingGood.substitute(
                        num=NumberOfPings,
                        tim=tim,
                        min=values[0],
                        avg=values[1],
                        max=values[2],
                    )
                )
                print(
                    LogPingGood.substitute(
                        num=NumberOfPings,
                        tim=tim,
                        min=values[0],
                        avg=values[1],
                        max=values[2],
                    )
                )
                if debug is True:
                    _w1.txtErrors.insert(
                        END,
                        LogPingGood.substitute(
                            num=NumberOfPings,
                            tim=tim,
                            min=values[0],
                            avg=values[1],
                            max=values[2],
                        )
                        + "\n",
                    )
    except:
        _w1.lblExternalIP.configure(background="red2")
        failed += 1
        _w1.FailedPings.set(failed)
        logging.warning(LogPingFail.substitute(num=NumberOfPings, tim=tim))
        _w1.txtErrors.insert(
            END, LogPingFail.substitute(num=NumberOfPings, tim=tim) + "\n"
        )

        if debug:
            print(LogPingFail.substitute(num=NumberOfPings, tim=tim))

    _w1.PingsDone.set(NumberOfPings)
    if int(_w1.TimesToPing.get()) != 0:
        if NumberOfPings >= int(_w1.TimesToPing.get()):
            print(LogFinish)
            root.after_cancel(Timer_id)
            Running = "0"
            logging.info(LogFinish)
            _w1.txtErrors.insert(END, LogFinish + "\n")
            _w1.btnStart.config(text="Start")
        else:
            delay = int(_w1.PingDelay.get()) * 1000
            Timer_id = root.after(delay, on_tick)
    else:
        delay = int(_w1.PingDelay.get()) * 1000
        Timer_id = root.after(delay, on_tick)


def do_ping(address, count, wait):
    # ======================================================
    # function: do_ping()
    # ======================================================
    # Expects:
    #    address - String - ip address of the site to ping
    #    count   - String - Number of times to ping in this call
    #    wait    - String - Number of seconds to wait for the
    #                         child process to terminate
    # -----------------------------------
    # Returns:
    #    On good : 0, [min time, avg time, max time, mdev time]
    #    On error: response, [0,0,0,0]
    # -----------------------------------
    print(
        f"Attempting to ping IP {address} {count} times with a delay of {wait} between each attempt"
    )
    if platform.system() == "Windows":
        # Windows version of ping uses a different command for
        # count and wait than the Linux version does...
        p = subprocess.Popen(
            ["ping", address, "-n", count, "-w", wait], stdout=subprocess.PIPE
        )
        tempresp = p.wait()
        pcom1 = p.communicate()
        pcom = pcom1[0]
        if tempresp == 0:
            resp = 0
        else:
            resp = 1  # pcom1[1]
        if resp == 0:
            # It also returns the data in a different format than
            # the linux version does.

            s = pcom.decode("ascii")
            s1 = s[s.find("Minimum = ") :]
            s1 = s1.replace("ms", "")
            s1 = s1.replace(",", "")
            s2 = s1.split()
            min = s2[2]
            max = s2[5]
            avg = s2[8]
            values = [min, avg, max]
            t = values
        else:
            t = 1
            values = [0, 0, 0]
        return resp, t
    else:
        try:
            p = subprocess.Popen(
                ["ping", address, "-c", count, "-W", wait], stdout=subprocess.PIPE
            )

            tmp = p.communicate()
            pcom = tmp[0].decode("ascii")
            if tmp[1] is None:
                resp = 0
            else:
                resp = tmp[1]
            start = pcom.find("rtt min/avg/max/mdev = ")
            end = pcom.rfind("ms")
            values = pcom[start + 23 : end]
            t = values.split("/")
            print(f"T: {t}")
        except:
            resp = 1
            t = [0, 0, 0, 0]
        return resp, t


def start_log():
    # ======================================================
    # function: start_log
    # ======================================================
    # initiates the log file and enters base information...
    # ======================================================
    global siteIpList, rblist
    ver = sys.version_info
    IP, Gateway, hostname = getLocalInfo()
    now = datetime.datetime.now().time()
    tim = datetime.datetime.now().strftime("%x %X")
    logging.basicConfig(
        filename="Pinger.log",
        filemode="w",
        format="%(levelname)s : %(message)s",
        level=logging.DEBUG,
    )
    logging.info(PyVer.substitute(maj=ver[0], min=ver[1], mic=ver[2]))
    if debug:
        print(PyVer.substitute(maj=ver[0], min=ver[1], mic=ver[2]))
    # logging.info("Operating platform: {0}".format(osplatform))

    logging.info(OpPlatform.substitute(op=osplatform))
    if debug:
        print(OpPlatform.substitute(op=osplatform))
    logging.info("Pinger Version: {0}".format(Version))
    logging.info("================================================")
    logging.info(LogStart.substitute(time=tim))

    if debug:
        print(LogStart.substitute(time=tim))
    which = _w1.selectbutton.get()
    # which = siteIpList[siteiplist]
    pingto = siteIpList[which]
    if debug:
        print(f"Target IP: {pingto}")
    logging.info(PingToDisp.substitute(to=pingto))
    if debug:
        print(PingToDisp.substitute(to=pingto))
    logging.info(
        LocalNameAddressGateway.substitute(host=hostname, ip=IP, gateway=Gateway)
    )
    if debug:
        print(LocalNameAddressGateway.substitute(host=hostname, ip=IP, gateway=Gateway))

    # if you are having issues with your internet connection, you
    # might have to 'force' the PublicIP address.
    pubip = getPublicIp()
    if pubip != 0:
        if debug:
            print(PublicIP.substitute(pubip=pubip))
        logging.info(PublicIP.substitute(pubip=pubip))
    else:
        if debug:
            print(PublicIP.substitute(pubip=_w1.ExternalIP.get()))
        logging.info(PublicIP.substitute(pubip=_w1.ExternalIP.get()))


def OnBtnStart():
    # ======================================================
    # callback function OnBtnStart()
    # ======================================================
    # Called when the 'Start' button on UI is clicked
    # ======================================================
    if debug:
        print("PingerML_support.OnBtnStart")
        sys.stdout.flush()
    global NumberOfPings, Running, Timer_id
    global failed, slow
    start_log()
    # -----------------------------------
    if Running == "0":
        NumberOfPings = 0
        failed = 0
        slow = 0
        _w1.FailedPings.set(failed)
        _w1.SlowPings.set(slow)
        Running = "1"
        _w1.btnStart.config(text=StopButtonLabel)
        delay = _w1.PingDelay.get()
        if debug:
            if _w1.TimesToPing.get() == 0:
                logging.info(LogLine1.substitute(delay=delay))
            else:
                logging.info(
                    LogLine2.substitute(pings=_w1.TimesToPing.get(), delay=delay)
                )
        Timer_id = root.after(0, on_tick)
    else:
        Running = "0"
        logging.info(LogFinish)
        _w1.txtErrors.insert(END, LogFinish + "\n")
        _w1.btnStart.config(text=StartButtonLabel)
        root.after_cancel(Timer_id)  # Cancel the 'timer'


def do_languages(Language):
    # ======================================================
    # function do_languages()
    # ======================================================
    # assigns the proper language files based on variable Language
    # ======================================================
    global location
    print(f"Base Location: {location}")
    uiFilename = ""
    basedir = os.path.join(location, "languages")
    if Language == "English":
        uiFilename = os.path.join(basedir, "UI-Strings-English.txt")
        dataFilename = os.path.join(basedir, "data-Strings-English.txt")
    elif Language == "Norwegian":
        uiFilename = os.path.join(basedir, "UI-Strings-Norwegian.txt")
        dataFilename = os.path.join(basedir, "data-Strings-Norwegian.txt")
    elif Language == "Spanish":
        uiFilename = os.path.join(basedir, "UI-Strings-Spanish.txt")
        dataFilename = os.path.join(basedir, "data-Strings-Spanish.txt")
    elif Language == "French":
        uiFilename = os.path.join(basedir, "UI-Strings-French.txt")
        dataFilename = os.path.join(basedir, "data-Strings-French.txt")
    elif Language == "Italian":
        uiFilename = os.path.join(basedir, "UI-Strings-Italian.txt")
        dataFilename = os.path.join(basedir, "data-Strings-Italian.txt")
    else:
        print("FAIL")
        uiFilename = os.path.join(basedir, "UI-Strings-English.txt")
        dataFilename = os.path.join(basedir, "data-Strings-English.txt")
    if debug:
        print(f"UI Filename: {uiFilename}")
        print(f"Data Filename: {dataFilename}")
    load_UI_strings(uiFilename)
    set_UI_strings()
    load_Data_strings(dataFilename)


def load_UI_strings(uiFilename):
    # ======================================================
    # function load_UI_strings()
    # ======================================================
    # Loads the UI-Strings-Language file from the list
    # created by read_file() and assigns each item to
    # a global variable to load UI static information.
    # ======================================================
    global ProgInfo, Copyright, ProgName, AuthorName, DebugOn, PyVer, LogStart, Version
    # Read the sample file
    data = read_file(uiFilename)
    # There should have been 11 lines loaded from the sample file. (0-10)
    global ProgName
    ProgName = data[0]

    global SitesLabel
    SitesLabel = data[1]
    global ExternalIPLabel
    ExternalIPLabel = data[2]
    global LastPingTimeLabel
    LastPingTimeLabel = data[3]
    global PingsDoneLabel
    PingsDoneLabel = data[4]
    global SlowPingsLabel
    SlowPingsLabel = data[5]
    global FailedPingsLabel
    FailedPingsLabel = data[6]
    global PingDelayLabel
    PingDelayLabel = data[7]
    global TimesToPingLabel
    TimesToPingLabel = data[8]
    global StartButtonLabel
    StartButtonLabel = data[9]
    global StopButtonLabel
    StopButtonLabel = data[10]


def set_UI_strings():
    # ======================================================
    # function set_UI_strings()
    # ======================================================
    # after globals are set in load_Data_strings function
    # this routine assigns those values to static text on UI
    # ======================================================
    global ProgName, SitesLabel, ExternalIPLabel, LastPingTimeLabel
    global PingsDoneLabel, SlowPingsLabel, PingDelayLabel
    global TimesToPingLabel, StartButtonLabel, StopButtonLabel
    root.title(ProgName + " " + Language)  # Title
    _w1.lframePingTo.config(text=SitesLabel)  # Ping to sites
    _w1.Label1.config(font=("DejaVu Sans", 9))
    _w1.Label1.config(text=ExternalIPLabel)  # external IP
    _w1.Label3.config(font=("DejaVu Sans", 9))
    _w1.Label3.config(text=LastPingTimeLabel)  # last ping time
    _w1.Label5.config(font=("DejaVu Sans", 9))
    _w1.Label5.config(text=PingsDoneLabel)  # pings done
    _w1.Label7.config(font=("DejaVu Sans", 9))
    _w1.Label7.config(text=SlowPingsLabel)  # slow pings
    _w1.Label9.config(font=("DejaVu Sans", 9))
    _w1.Label9.config(text=FailedPingsLabel)  # failed pings
    _w1.Label11.config(font=("DejaVu Sans", 8))
    _w1.Label11.config(text=PingDelayLabel)  # delay between
    _w1.Label12.config(font=("DejaVu Sans", 8))
    _w1.Label12.config(text=TimesToPingLabel)  # times to ping
    _w1.btnStart.config(text=StartButtonLabel)  # Start button


def load_Data_strings(Filename):
    # ======================================================
    # function load_data_strings()
    # ======================================================
    # Loads the data-Strings-{Language} file from the list
    # created by read_file() and assigns each item to
    # a global variable
    # ======================================================
    data = read_file(Filename)
    # There should have been 18 lines loaded from the sample file. (0-17)
    global LogLine1
    LogLine1 = Template(data[0])
    global LogLine2
    LogLine2 = Template(data[1])
    global LogFinish
    LogFinish = data[2]
    global ProgInfo
    ProgInfo = data[3]
    global Copyright
    Copyright = data[4]
    global ProgName
    ProgName = data[5]
    global AuthorName
    AuthorName = data[6]
    global DebugOn
    DebugOn = Template(data[7])
    global PyVer
    PyVer = Template(data[8])
    global LogStart
    LogStart = Template(data[9])
    global PingToDisp
    PingToDisp = Template(data[10])
    global LocalNameAddress
    LocalNameAddress = Template(data[11])
    global LocalNameAddressGateway
    LocalNameAddressGateway = Template(data[12])
    global PublicIP
    PublicIP = Template(data[13])
    global SlowPingDisplay
    SlowPingDisplay = Template(data[14])
    global LogPingFail
    LogPingFail = Template(data[15])
    global LogPingGood
    LogPingGood = Template(data[16])
    global OpPlatform
    OpPlatform = Template(data[17])


def mnuFileExit():
    # ======================================================
    # function mnuFileExit()
    # ======================================================
    # called when menu item File | Exit is clicked
    # ======================================================
    if debug:
        print("PingerML_support.mnuFileExit")
        sys.stdout.flush()
    sys.exit()


def mnuHelpAbout(*args):
    # ======================================================
    # function mnuHelpAbout()
    # ======================================================
    # called when menu item Help | About is clicked
    # ======================================================
    # Show the generic about box
    # ======================================================
    if debug:
        print("PingerML_support.mnuHelpAbout")
        sys.stdout.flush()
    # ======================================================
    # Define the globals and load the information into the Labels in the form
    # ======================================================
    global temp
    global ProgInfo, Copyright, ProgName, AuthorName
    global DebugOn, PyVer, LogStart, Version
    hide_main()
    copyright_symbol = "\u00A9"
    _w2.ProgNameDisplay.set(ProgName)
    _w2.AuthorDisplay.set(f"Written by {AuthorName}")
    _w2.VersionDisplay.set(f"Version {Version}")
    _w2.CopyrightDisplay.set(Copyright)
    _w2.Scrolledtext1.insert(END, ProgInfo)
    root.update
    show_about()


def centre_screen(wid, hei):
    ws = root.winfo_screenwidth()
    hs = root.winfo_screenheight()
    x = (ws / 2) - (wid / 2)
    y = (hs / 2) - (hei / 2)
    root.geometry("%dx%d+%d+%d" % (wid, hei, x, y))


# BOOKMARK


def show_main():
    global _top1
    _top1.deiconify()


def hide_main():
    global _top1
    _top1.withdraw()


def show_about():
    global _top2
    _top2.deiconify()


def hide_about():
    global _top2
    _top2.withdraw()


def on_btnAboutDismiss(*args):
    print("pinger7_support.on_btnAboutDismiss")
    for arg in args:
        print("    another arg:", arg)
    sys.stdout.flush()
    hide_about()
    show_main()


def on_rbSiteClick(*args):
    if debug:
        print("pinger7_support.on_rbSiteClick")
        for arg in args:
            print("    another arg:", arg)
        sys.stdout.flush()
    which = _w1.selectbutton.get()
    global siteIpList, TargetIP
    # global PingToAddress
    TargetIP = siteIpList[which]
    print(f"PingTo: {TargetIP}")


if __name__ == "__main__":
    pinger7.start_up()
